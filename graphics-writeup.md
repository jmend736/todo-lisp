# 6.945: Graphics Writeup


## Overview
This block of the program is responsible for taking input from the task schedule, as a list of dependencies, and generating graphviz dot files to display the schedule.

The goal of the graphics block will be to accomplish this task with few limitations on the format of the input. To do this, it will work on generic elements which the user will be able to define. If another format of input is desired, simple changes to the input are all that's needed.

## Interface
The input for the graphics block will be an association list with the work blocks and a specified format. The format will be built using generic elements. To define a format you must define the generic elements and pass both the format and elements into the function.

```scheme
;; To define a generic element
; predicate: checks whether passed element is of correct format
; return: function to be called with element to extract information
(d:generic-element predicare return)
```
given that a work block has this format
```scheme
('workblock
    ('block_id <id>)
    ('dependent_ids <dependencies>)
    ('description <description>)
    ('taskid <taskid>)
    ('duration <duration>)
    ('starttime <deadline>)
    ('deadline <deadline>)
    ('duration <duration>))
```

we would have to define generic elements for `blockid`, `dependent_ids`, `description`, etc. so an example format might look something like
```scheme
(d:block_id d:dependent_ids d:description ...)
```
where each of these are generic elements passed as a list.

| Field Name      | Field Description                                   | Example             |
| ----------      | -----------------                                   | -------             |
| `block_id`      | The ID for this specific work block                 | `2320`              |
| `dependent_ids` | A list of the IDs that depend on this element       | `'(2032 0329 9402)` |
| `taskid`        | The ID for the task that this work block belongs to | `4932`              |
| `starttime`     | The date and time that a task is scheduled to begin | `"0d-3h-10m"`       |

(I've omitted elements that are discussed earlier in the Task Parser section)


## Generic Elements
As discussed before generic elements are defined using
```scheme
(d:generic-element predicare return)
```
here they key take function is the `return` function. This is what decides how the element behaves and what it will be used for. For example, for dot to work, each of the blocks must have their own unique id (this is what the `block_id`) is, and we define a special generic element. The `return` function will return an element, which is a list where the first item is a `symbol` representing the type of element and next blocks are used for data. The identifying `symbol` is used by the assembler to know how to use the element.

There are three general types of elements

#### Base Elements
These are used as the names for nodes in dot. These are the base for the graph.

#### Option Element
These are options that are added onto nodes or edges on the graph. These will typically be different properties that are applied to the graph (such as style properties like color, etc).

#### Multiple Elements
These are properties which will require processing more than one elements'. An example of this is rank, as we'll need to group all of the similarly ranked elements into one block.

## Combination of Elements

Combination is a matter of processing them into a graph format
```scheme
('graph (('linename1 ...) ('linename2 ...) ...))
```
The graph would be a linked list where each element is a named line to be generated in the final output.

This format allows for generation to be simple, to create a new edge, we can simply create a new element in the graph alist. The other case, if we want to edit or append something to an element, we can search the graph alist, and edit that element individually.

This is supposed to be internal, but extending this to add new features is straightforward, as you simply need to define the function that will edit the graph for a specific element.

## Output
The final output is generated by converting the `graph` object into a string and writing that to a file. Then I run a terminal command to generate the final product.

The code for writing the file and running the terminal code are based on to that used in the problem sets.

# Presentation

## 0. Motivations

## 1. What is todo-lisp? What does it do?

## 2. [DEMO]

## 3. Interfaces between Subparts

## 4. Key Implementaton Design Decisions

## 5. Conclusions & Future Work

